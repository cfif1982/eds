package document

import (
	"context"
	"fmt"
	"log/slog"

	"github.com/google/uuid"
)

func (u *UseCases) Send(
	ctx context.Context,
	documentID uuid.UUID,
	signersEmail []string,
	filesURL []string,
) error {
	// TODO удаляем все подписи этого документа из БД
	// TODO удаляем все файлы этого документа из БД
	// TODO загружаем файлы на сервер и схраняю в бд. Получаю слайс из id этих файлов из БД
	// Q: ну вообще, по DDD тут нужно найти не просто id этих файлов, а прям создать модели этих файлов, добавить их в документ и в таком виде сохранить документ
	// но можно и просто передать в базу id документа и список id этих файлов
	var filesID []uuid.UUID
	// TODO получаю слайс id подписантов по их email
	// Q: точно такая же история как и с файлами
	var signersID []uuid.UUID

	// сохраняем документ в БД
	// Q: вопрос вытекает из предыдущего. Нужно ли мне здесь создавать модель Document со всеми данными
	// и уже эту модель передавать на сохранение или тут можно передать id документа и список id этих файлов и подписантов?
	err := u.repo.Update(ctx, doc)

	// Q: работа с ошибками
	if err != nil {
		// здесь у меня идет бизнес логика обработки ошибки
		// я проверяю - если это моя ошибка из models, например models.ErrUserNotFound
		// то я просто верну ошибку дальше по стеку
		// если это ни одна из моих ошибок, то я просто добавлю текст - ошибка в Add useCase и верну дальше
		// или тут в любом случае стоит обернуть ошибку с сообщением о месте ошибки - useCase add document?
		return fmt.Errorf("update document useCase error: %w", err)
	}

	// Q: логирую результат в use case. Правильно делаю, что здесь логирую?
	// т.е. в слое репоитория ничегоне логирую, только ошибки передаю
	// а здесь логирую результат
	u.log.Info("document updated", slog.Any("documentID", documentID))

	// TODO отправляем сообщение первому подписанту
	// Q: вопрос сообщения подписантам нужно отправлять в заданном порядке
	// я это реализовал следующим образом:
	// чтобы не создавать дополнителную таблицу с подписантами документа и их порядком,
	// я воспользьвался таблицей signatures. Теперь при обновлении данных документа,
	// в таблицу files добавляю файлы, и сразу добавляю записи в таблицу signatures всех подписантов данного файла.
	// но с пустым полем signature_file_name, т.к. файл еще не подписан данным подписантом
	// нормальное решение?
	return nil
}
